28,29c28,29
< namespace coroutines {
< namespace detail {
---
>     namespace coroutines {
>         namespace detail {
31,36c31,36
< template< typename Arg >
< class symmetric_coroutine_call
< {
< private:
<     template< typename X >
<     friend class symmetric_coroutine_yield;
---
>             template< typename Arg >
>             class symmetric_coroutine_call
>             {
>             private:
>                 template< typename X >
>                 friend class symmetric_coroutine_yield;
38c38
<     typedef symmetric_coroutine_impl< Arg >   impl_type;
---
>                 typedef symmetric_coroutine_impl< Arg >   impl_type;
40c40
<     BOOST_MOVABLE_BUT_NOT_COPYABLE( symmetric_coroutine_call)
---
>                 BOOST_MOVABLE_BUT_NOT_COPYABLE( symmetric_coroutine_call)
42c42
<     struct dummy {};
---
>                 struct dummy {};
44c44
<     impl_type       *   impl_;
---
>                 impl_type       *   impl_;
46,48c46,48
< public:
<     typedef Arg                                value_type;
<     typedef symmetric_coroutine_yield< Arg >   yield_type;
---
>             public:
>                 typedef Arg                                value_type;
>                 typedef symmetric_coroutine_yield< Arg >   yield_type;
50,52c50,52
<     symmetric_coroutine_call() BOOST_NOEXCEPT :
<         impl_( 0)
<     {}
---
>                 symmetric_coroutine_call() BOOST_NOEXCEPT :
>                 impl_( 0)
>                 {}
56c56
<     typedef void ( * coroutine_fn)( yield_type &);
---
>                 typedef void ( * coroutine_fn)( yield_type &);
67c67
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
73c73
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
78c78
<                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
92c92
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
98c98
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
103c103
<                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
107,155c107,155
<     template< typename Fn >
<     explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
<                                        attributes const& attrs = attributes(),
<                                        stack_allocator stack_alloc = stack_allocator() ) :
<         impl_( 0)
<     {
<         // create a stack-context
<         stack_context stack_ctx;
<         // allocate the coroutine-stack
<         stack_alloc.allocate( stack_ctx, attrs.size);
<         BOOST_ASSERT( 0 < stack_ctx.sp);
<         // typedef of internal coroutine-type
<         typedef symmetric_coroutine_object< Arg, Fn, stack_allocator > object_t;
<         // reserve space on top of coroutine-stack for internal coroutine-type
<         stack_context internal_stack_ctx;
<         internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
<         internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.size);
<         // placement new for internal coroutine
<         impl_ = new ( internal_stack_ctx.sp) object_t(
<                     boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
<         BOOST_ASSERT( impl_);
<     }
< 
<     template< typename Fn, typename StackAllocator >
<     explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
<                                        attributes const& attrs,
<                                        StackAllocator stack_alloc) :
<         impl_( 0)
<     {
<         // create a stack-context
<         stack_context stack_ctx;
<         // allocate the coroutine-stack
<         stack_alloc.allocate( stack_ctx, attrs.size);
<         BOOST_ASSERT( 0 < stack_ctx.sp);
<         // typedef of internal coroutine-type
<         typedef symmetric_coroutine_object< Arg, Fn, StackAllocator > object_t;
<         // reserve space on top of coroutine-stack for internal coroutine-type
<         stack_context internal_stack_ctx;
<         internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
<         internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.size);
<         // placement new for internal coroutine
<         impl_ = new ( internal_stack_ctx.sp) object_t(
<                     boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
<         BOOST_ASSERT( impl_);
<     }
---
>                 template< typename Fn >
>                 explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
>                 attributes const& attrs = attributes(),
>                         stack_allocator stack_alloc = stack_allocator() ) :
>                 impl_( 0)
>                 {
>                     // create a stack-context
>                     stack_context stack_ctx;
>                     // allocate the coroutine-stack
>                     stack_alloc.allocate( stack_ctx, attrs.size);
>                     BOOST_ASSERT( NULL != stack_ctx.sp);
>                     // typedef of internal coroutine-type
>                     typedef symmetric_coroutine_object< Arg, Fn, stack_allocator > object_t;
>                     // reserve space on top of coroutine-stack for internal coroutine-type
>                     stack_context internal_stack_ctx;
>                     internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
>                     BOOST_ASSERT( NULL != internal_stack_ctx.sp);
>                     internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
>                     BOOST_ASSERT( 0 < internal_stack_ctx.size);
>                     // placement new for internal coroutine
>                     impl_ = new ( internal_stack_ctx.sp) object_t(
>                             boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
>                     BOOST_ASSERT( impl_);
>                 }
> 
>                 template< typename Fn, typename StackAllocator >
>                 explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
>                                                    attributes const& attrs,
>                                                    StackAllocator stack_alloc) :
>                         impl_( 0)
>                 {
>                     // create a stack-context
>                     stack_context stack_ctx;
>                     // allocate the coroutine-stack
>                     stack_alloc.allocate( stack_ctx, attrs.size);
>                     BOOST_ASSERT( NULL != stack_ctx.sp);
>                     // typedef of internal coroutine-type
>                     typedef symmetric_coroutine_object< Arg, Fn, StackAllocator > object_t;
>                     // reserve space on top of coroutine-stack for internal coroutine-type
>                     stack_context internal_stack_ctx;
>                     internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
>                     BOOST_ASSERT( NULL != internal_stack_ctx.sp);
>                     internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
>                     BOOST_ASSERT( 0 < internal_stack_ctx.size);
>                     // placement new for internal coroutine
>                     impl_ = new ( internal_stack_ctx.sp) object_t(
>                             boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
>                     BOOST_ASSERT( impl_);
>                 }
157c157
<     template< typename Fn >
---
>                 template< typename Fn >
167c167
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
173c173
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
177c177
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
191c191
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
197c197
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
201c201
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
215c215
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
221c221
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
225c225
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
239c239
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
245c245
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
249c249
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
254,312c254,312
<     ~symmetric_coroutine_call()
<     {
<         if ( 0 != impl_)
<         {
<             impl_->destroy();
<             impl_ = 0;
<         }
<     }
< 
<     symmetric_coroutine_call( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT :
<         impl_( 0)
<     { swap( other); }
< 
<     symmetric_coroutine_call & operator=( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT
<     {
<         symmetric_coroutine_call tmp( boost::move( other) );
<         swap( tmp);
<         return * this;
<     }
< 
<     BOOST_EXPLICIT_OPERATOR_BOOL();
< 
<     bool operator!() const BOOST_NOEXCEPT
<     { return 0 == impl_ || impl_->is_complete() || impl_->is_running(); }
< 
<     void swap( symmetric_coroutine_call & other) BOOST_NOEXCEPT
<     { std::swap( impl_, other.impl_); }
< 
<     symmetric_coroutine_call & operator()( Arg arg) BOOST_NOEXCEPT
<     {
<         BOOST_ASSERT( * this);
< 
<         impl_->resume( arg);
<         return * this;
<     }
< };
< 
< template< typename Arg >
< class symmetric_coroutine_call< Arg & >
< {
< private:
<     template< typename X >
<     friend class symmetric_coroutine_yield;
< 
<     typedef symmetric_coroutine_impl< Arg & >     impl_type;
< 
<     BOOST_MOVABLE_BUT_NOT_COPYABLE( symmetric_coroutine_call)
< 
<     struct dummy {};
< 
<     impl_type       *   impl_;
< 
< public:
<     typedef Arg                                    value_type;
<     typedef symmetric_coroutine_yield< Arg & >     yield_type;
< 
<     symmetric_coroutine_call() BOOST_NOEXCEPT :
<         impl_( 0)
<     {}
---
>                 ~symmetric_coroutine_call()
>                 {
>                     if ( 0 != impl_)
>                     {
>                         impl_->destroy();
>                         impl_ = 0;
>                     }
>                 }
> 
>                 symmetric_coroutine_call( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT :
>                 impl_( 0)
>                 { swap( other); }
> 
>                 symmetric_coroutine_call & operator=( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT
>                 {
>                     symmetric_coroutine_call tmp( boost::move( other) );
>                     swap( tmp);
>                     return * this;
>                 }
> 
>                 BOOST_EXPLICIT_OPERATOR_BOOL();
> 
>                 bool operator!() const BOOST_NOEXCEPT
>                 { return 0 == impl_ || impl_->is_complete() || impl_->is_running(); }
> 
>                 void swap( symmetric_coroutine_call & other) BOOST_NOEXCEPT
>                 { std::swap( impl_, other.impl_); }
> 
>                 symmetric_coroutine_call & operator()( Arg arg) BOOST_NOEXCEPT
>                 {
>                     BOOST_ASSERT( * this);
> 
>                     impl_->resume( arg);
>                     return * this;
>                 }
>             };
> 
>             template< typename Arg >
>             class symmetric_coroutine_call< Arg & >
>             {
>             private:
>                 template< typename X >
>                 friend class symmetric_coroutine_yield;
> 
>                 typedef symmetric_coroutine_impl< Arg & >     impl_type;
> 
>                 BOOST_MOVABLE_BUT_NOT_COPYABLE( symmetric_coroutine_call)
> 
>                 struct dummy {};
> 
>                 impl_type       *   impl_;
> 
>             public:
>                 typedef Arg                                    value_type;
>                 typedef symmetric_coroutine_yield< Arg & >     yield_type;
> 
>                 symmetric_coroutine_call() BOOST_NOEXCEPT :
>                 impl_( 0)
>                 {}
316c316
<     typedef void ( * coroutine_fn)( yield_type &);
---
>                 typedef void ( * coroutine_fn)( yield_type &);
327c327
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
333c333
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
338c338
<                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
352c352
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
358c358
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
363c363
<                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
367,415c367,415
<     template< typename Fn >
<     explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
<                                        attributes const& attrs = attributes(),
<                                        stack_allocator stack_alloc = stack_allocator() ) :
<         impl_( 0)
<     {
<         // create a stack-context
<         stack_context stack_ctx;
<         // allocate the coroutine-stack
<         stack_alloc.allocate( stack_ctx, attrs.size);
<         BOOST_ASSERT( 0 < stack_ctx.sp);
<         // typedef of internal coroutine-type
<         typedef symmetric_coroutine_object< Arg &, Fn, stack_allocator > object_t;
<         // reserve space on top of coroutine-stack for internal coroutine-type
<         stack_context internal_stack_ctx;
<         internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
<         internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.size);
<         // placement new for internal coroutine
<         impl_ = new ( internal_stack_ctx.sp) object_t(
<                     boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
<         BOOST_ASSERT( impl_);
<     }
< 
<     template< typename Fn, typename StackAllocator >
<     explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
<                                        attributes const& attrs,
<                                        StackAllocator stack_alloc) :
<         impl_( 0)
<     {
<         // create a stack-context
<         stack_context stack_ctx;
<         // allocate the coroutine-stack
<         stack_alloc.allocate( stack_ctx, attrs.size);
<         BOOST_ASSERT( 0 < stack_ctx.sp);
<         // typedef of internal coroutine-type
<         typedef symmetric_coroutine_object< Arg &, Fn, StackAllocator > object_t;
<         // reserve space on top of coroutine-stack for internal coroutine-type
<         stack_context internal_stack_ctx;
<         internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
<         internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.size);
<         // placement new for internal coroutine
<         impl_ = new ( internal_stack_ctx.sp) object_t(
<                     boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
<         BOOST_ASSERT( impl_);
<     }
---
>                 template< typename Fn >
>                 explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
>                                                    attributes const& attrs = attributes(),
>                                                    stack_allocator stack_alloc = stack_allocator() ) :
>                         impl_( 0)
>                 {
>                     // create a stack-context
>                     stack_context stack_ctx;
>                     // allocate the coroutine-stack
>                     stack_alloc.allocate( stack_ctx, attrs.size);
>                     BOOST_ASSERT( NULL != stack_ctx.sp);
>                     // typedef of internal coroutine-type
>                     typedef symmetric_coroutine_object< Arg &, Fn, stack_allocator > object_t;
>                     // reserve space on top of coroutine-stack for internal coroutine-type
>                     stack_context internal_stack_ctx;
>                     internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
>                     BOOST_ASSERT( NULL != internal_stack_ctx.sp);
>                     internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
>                     BOOST_ASSERT( 0 < internal_stack_ctx.size);
>                     // placement new for internal coroutine
>                     impl_ = new ( internal_stack_ctx.sp) object_t(
>                             boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
>                     BOOST_ASSERT( impl_);
>                 }
> 
>                 template< typename Fn, typename StackAllocator >
>                 explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
>                                                    attributes const& attrs,
>                                                    StackAllocator stack_alloc) :
>                         impl_( 0)
>                 {
>                     // create a stack-context
>                     stack_context stack_ctx;
>                     // allocate the coroutine-stack
>                     stack_alloc.allocate( stack_ctx, attrs.size);
>                     BOOST_ASSERT( NULL != stack_ctx.sp);
>                     // typedef of internal coroutine-type
>                     typedef symmetric_coroutine_object< Arg &, Fn, StackAllocator > object_t;
>                     // reserve space on top of coroutine-stack for internal coroutine-type
>                     stack_context internal_stack_ctx;
>                     internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
>                     BOOST_ASSERT( NULL != internal_stack_ctx.sp);
>                     internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
>                     BOOST_ASSERT( 0 < internal_stack_ctx.size);
>                     // placement new for internal coroutine
>                     impl_ = new ( internal_stack_ctx.sp) object_t(
>                             boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
>                     BOOST_ASSERT( impl_);
>                 }
417c417
<     template< typename Fn >
---
>                 template< typename Fn >
427c427
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
433c433
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
437c437
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
451c451
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
457c457
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
461c461
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
475c475
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
481c481
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
485c485
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
499c499
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
505c505
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
509c509
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
514,572c514,572
<     ~symmetric_coroutine_call()
<     {
<         if ( 0 != impl_)
<         {
<             impl_->destroy();
<             impl_ = 0;
<         }
<     }
< 
<     symmetric_coroutine_call( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT :
<         impl_( 0)
<     { swap( other); }
< 
<     symmetric_coroutine_call & operator=( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT
<     {
<         symmetric_coroutine_call tmp( boost::move( other) );
<         swap( tmp);
<         return * this;
<     }
< 
<     BOOST_EXPLICIT_OPERATOR_BOOL();
< 
<     bool operator!() const BOOST_NOEXCEPT
<     { return 0 == impl_ || impl_->is_complete() || impl_->is_running(); }
< 
<     void swap( symmetric_coroutine_call & other) BOOST_NOEXCEPT
<     { std::swap( impl_, other.impl_); }
< 
<     symmetric_coroutine_call & operator()( Arg & arg) BOOST_NOEXCEPT
<     {
<         BOOST_ASSERT( * this);
< 
<         impl_->resume( arg);
<         return * this;
<     }
< };
< 
< template<>
< class symmetric_coroutine_call< void >
< {
< private:
<     template< typename X >
<     friend class symmetric_coroutine_yield;
< 
<     typedef symmetric_coroutine_impl< void >        impl_type;
< 
<     BOOST_MOVABLE_BUT_NOT_COPYABLE( symmetric_coroutine_call)
< 
<     struct dummy {};
< 
<     impl_type       *   impl_;
< 
< public:
<     typedef void                                     value_type;
<     typedef symmetric_coroutine_yield< void >        yield_type;
< 
<     symmetric_coroutine_call() BOOST_NOEXCEPT :
<         impl_( 0)
<     {}
---
>                 ~symmetric_coroutine_call()
>                 {
>                     if ( 0 != impl_)
>                     {
>                         impl_->destroy();
>                         impl_ = 0;
>                     }
>                 }
> 
>                 symmetric_coroutine_call( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT :
>                 impl_( 0)
>                 { swap( other); }
> 
>                 symmetric_coroutine_call & operator=( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT
>                 {
>                     symmetric_coroutine_call tmp( boost::move( other) );
>                     swap( tmp);
>                     return * this;
>                 }
> 
>                 BOOST_EXPLICIT_OPERATOR_BOOL();
> 
>                 bool operator!() const BOOST_NOEXCEPT
>                 { return 0 == impl_ || impl_->is_complete() || impl_->is_running(); }
> 
>                 void swap( symmetric_coroutine_call & other) BOOST_NOEXCEPT
>                 { std::swap( impl_, other.impl_); }
> 
>                 symmetric_coroutine_call & operator()( Arg & arg) BOOST_NOEXCEPT
>                 {
>                     BOOST_ASSERT( * this);
> 
>                     impl_->resume( arg);
>                     return * this;
>                 }
>             };
> 
>             template<>
>             class symmetric_coroutine_call< void >
>             {
>             private:
>                 template< typename X >
>                 friend class symmetric_coroutine_yield;
> 
>                 typedef symmetric_coroutine_impl< void >        impl_type;
> 
>                 BOOST_MOVABLE_BUT_NOT_COPYABLE( symmetric_coroutine_call)
> 
>                 struct dummy {};
> 
>                 impl_type       *   impl_;
> 
>             public:
>                 typedef void                                     value_type;
>                 typedef symmetric_coroutine_yield< void >        yield_type;
> 
>                 symmetric_coroutine_call() BOOST_NOEXCEPT :
>                 impl_( 0)
>                 {}
576c576
<     typedef void ( * coroutine_fn)( yield_type &);
---
>                 typedef void ( * coroutine_fn)( yield_type &);
587c587
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
593c593
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
598c598
<                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
612c612
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
618c618
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
623c623
<                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>                     boost::forward< coroutine_fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
627,675c627,675
<     template< typename Fn >
<     explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
<                                        attributes const& attrs = attributes(),
<                                        stack_allocator stack_alloc = stack_allocator() ) :
<         impl_( 0)
<     {
<         // create a stack-context
<         stack_context stack_ctx;
<         // allocate the coroutine-stack
<         stack_alloc.allocate( stack_ctx, attrs.size);
<         BOOST_ASSERT( 0 < stack_ctx.sp);
<         // typedef of internal coroutine-type
<         typedef symmetric_coroutine_object< void, Fn, stack_allocator > object_t;
<         // reserve space on top of coroutine-stack for internal coroutine-type
<         stack_context internal_stack_ctx;
<         internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
<         internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.size);
<         // placement new for internal coroutine
<         impl_ = new ( internal_stack_ctx.sp) object_t(
<                     boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
<         BOOST_ASSERT( impl_);
<     }
< 
<     template< typename Fn, typename StackAllocator >
<     explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
<                                        attributes const& attrs,
<                                        StackAllocator stack_alloc) :
<         impl_( 0)
<     {
<         // create a stack-context
<         stack_context stack_ctx;
<         // allocate the coroutine-stack
<         stack_alloc.allocate( stack_ctx, attrs.size);
<         BOOST_ASSERT( 0 < stack_ctx.sp);
<         // typedef of internal coroutine-type
<         typedef symmetric_coroutine_object< void, Fn, StackAllocator > object_t;
<         // reserve space on top of coroutine-stack for internal coroutine-type
<         stack_context internal_stack_ctx;
<         internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
<         internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
<         BOOST_ASSERT( 0 < internal_stack_ctx.size);
<         // placement new for internal coroutine
<         impl_ = new ( internal_stack_ctx.sp) object_t(
<                     boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
<         BOOST_ASSERT( impl_);
<     }
---
>                 template< typename Fn >
>                 explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
>                                                    attributes const& attrs = attributes(),
>                                                    stack_allocator stack_alloc = stack_allocator() ) :
>                         impl_( 0)
>                 {
>                     // create a stack-context
>                     stack_context stack_ctx;
>                     // allocate the coroutine-stack
>                     stack_alloc.allocate( stack_ctx, attrs.size);
>                     BOOST_ASSERT( NULL != stack_ctx.sp);
>                     // typedef of internal coroutine-type
>                     typedef symmetric_coroutine_object< void, Fn, stack_allocator > object_t;
>                     // reserve space on top of coroutine-stack for internal coroutine-type
>                     stack_context internal_stack_ctx;
>                     internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
>                     BOOST_ASSERT( NULL != internal_stack_ctx.sp);
>                     internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
>                     BOOST_ASSERT( 0 < internal_stack_ctx.size);
>                     // placement new for internal coroutine
>                     impl_ = new ( internal_stack_ctx.sp) object_t(
>                             boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
>                     BOOST_ASSERT( impl_);
>                 }
> 
>                 template< typename Fn, typename StackAllocator >
>                 explicit symmetric_coroutine_call( BOOST_RV_REF( Fn) fn,
>                                                    attributes const& attrs,
>                                                    StackAllocator stack_alloc) :
>                         impl_( 0)
>                 {
>                     // create a stack-context
>                     stack_context stack_ctx;
>                     // allocate the coroutine-stack
>                     stack_alloc.allocate( stack_ctx, attrs.size);
>                     BOOST_ASSERT( NULL != stack_ctx.sp);
>                     // typedef of internal coroutine-type
>                     typedef symmetric_coroutine_object< void, Fn, StackAllocator > object_t;
>                     // reserve space on top of coroutine-stack for internal coroutine-type
>                     stack_context internal_stack_ctx;
>                     internal_stack_ctx.sp = static_cast< char * >( stack_ctx.sp) - sizeof( object_t);
>                     BOOST_ASSERT( NULL != internal_stack_ctx.sp);
>                     internal_stack_ctx.size = stack_ctx.size - sizeof( object_t);
>                     BOOST_ASSERT( 0 < internal_stack_ctx.size);
>                     // placement new for internal coroutine
>                     impl_ = new ( internal_stack_ctx.sp) object_t(
>                             boost::forward< Fn >( fn), attrs, stack_ctx, internal_stack_ctx, stack_alloc);
>                     BOOST_ASSERT( impl_);
>                 }
677c677
<     template< typename Fn >
---
>                 template< typename Fn >
687c687
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
693c693
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
697c697
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
711c711
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
717c717
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
721c721
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
735c735
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
741c741
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
745c745
<         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc); 
---
>         impl_ = new ( internal_stack_ctx.sp) object_t( fn, attrs, stack_ctx, internal_stack_ctx, stack_alloc);
759c759
<         BOOST_ASSERT( 0 < stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != stack_ctx.sp);
765c765
<         BOOST_ASSERT( 0 < internal_stack_ctx.sp);
---
>         BOOST_ASSERT( NULL != internal_stack_ctx.sp);
774,814c774,814
<     ~symmetric_coroutine_call()
<     {
<         if ( 0 != impl_)
<         {
<             impl_->destroy();
<             impl_ = 0;
<         }
<     }
< 
<     inline symmetric_coroutine_call( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT :
<         impl_( 0)
<     { swap( other); }
< 
<     inline symmetric_coroutine_call & operator=( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT
<     {
<         symmetric_coroutine_call tmp( boost::move( other) );
<         swap( tmp);
<         return * this;
<     }
< 
<     BOOST_EXPLICIT_OPERATOR_BOOL();
< 
<     inline bool operator!() const BOOST_NOEXCEPT
<     { return 0 == impl_ || impl_->is_complete() || impl_->is_running(); }
< 
<     inline void swap( symmetric_coroutine_call & other) BOOST_NOEXCEPT
<     { std::swap( impl_, other.impl_); }
< 
<     inline symmetric_coroutine_call & operator()() BOOST_NOEXCEPT
<     {
<         BOOST_ASSERT( * this);
< 
<         impl_->resume();
<         return * this;
<     }
< };
< 
< template< typename Arg >
< void swap( symmetric_coroutine_call< Arg > & l,
<            symmetric_coroutine_call< Arg > & r)
< { l.swap( r); }
---
>                 ~symmetric_coroutine_call()
>                 {
>                     if ( 0 != impl_)
>                     {
>                         impl_->destroy();
>                         impl_ = 0;
>                     }
>                 }
> 
>                 inline symmetric_coroutine_call( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT :
>                 impl_( 0)
>                 { swap( other); }
> 
>                 inline symmetric_coroutine_call & operator=( BOOST_RV_REF( symmetric_coroutine_call) other) BOOST_NOEXCEPT
>                 {
>                     symmetric_coroutine_call tmp( boost::move( other) );
>                     swap( tmp);
>                     return * this;
>                 }
> 
>                 BOOST_EXPLICIT_OPERATOR_BOOL();
> 
>                 inline bool operator!() const BOOST_NOEXCEPT
>                 { return 0 == impl_ || impl_->is_complete() || impl_->is_running(); }
> 
>                 inline void swap( symmetric_coroutine_call & other) BOOST_NOEXCEPT
>                 { std::swap( impl_, other.impl_); }
> 
>                 inline symmetric_coroutine_call & operator()() BOOST_NOEXCEPT
>                 {
>                     BOOST_ASSERT( * this);
> 
>                     impl_->resume();
>                     return * this;
>                 }
>             };
> 
>             template< typename Arg >
>             void swap( symmetric_coroutine_call< Arg > & l,
>                        symmetric_coroutine_call< Arg > & r)
>             { l.swap( r); }
816c816
< }}}
---
>         }}}
