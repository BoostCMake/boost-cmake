// Copyright (c) 2008-2009 Ben Hanson
// Copyright (c) 2008-2011 Hartmut Kaiser
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file licence_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// Auto-generated by boost::lexer, do not edit

#if !defined(BOOST_SPIRIT_LEXER_NEXT_TOKEN_MATLIB_SWITCH_OCT__3_2018_21_59_15)
#define BOOST_SPIRIT_LEXER_NEXT_TOKEN_MATLIB_SWITCH_OCT__3_2018_21_59_15

#include <boost/detail/iterator.hpp>
#include <boost/spirit/home/support/detail/lexer/char_traits.hpp>

////////////////////////////////////////////////////////////////////////////////
// the generated table of state names and the tokenizer have to be
// defined in the boost::spirit::lex::lexertl::static_ namespace
namespace boost { namespace spirit { namespace lex { namespace lexertl { namespace static_ {

////////////////////////////////////////////////////////////////////////////////
// this table defines the names of the lexer states
char const* const lexer_state_names_matlib_switch[3] = 
{
    "INITIAL",
    "A",
    "B"
};

////////////////////////////////////////////////////////////////////////////////
// this variable defines the number of lexer states
std::size_t const lexer_state_count_matlib_switch = 3;

////////////////////////////////////////////////////////////////////////////////
// this function returns the next matched token
template<typename Iterator>
std::size_t next_token_matlib_switch (std::size_t& start_state_, bool& /*bol_*/, 
    Iterator &start_token_, Iterator const& end_, std::size_t& unique_id_)
{
    static std::size_t const npos = static_cast<std::size_t>(~0);

    if (start_token_ == end_)
    {
        unique_id_ = npos;
        return 0;
    }

again:
    Iterator curr_ = start_token_;
    bool end_state_ = false;
    std::size_t id_ = npos;
    std::size_t uid_ = npos;
    std::size_t end_start_state_ = start_state_;
    Iterator end_token_ = start_token_;

    char ch_ = 0;

    switch (start_state_)
    {
    case 0:
        goto state0_0;
        break;
    case 1:
        goto state1_0;
        break;
    case 2:
        goto state2_0;
        break;
    default:
        goto end;
        break;
    }

state0_0:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == '[') goto state0_1;
    goto end;

state0_1:
    end_state_ = true;
    id_ = 91;
    uid_ = 0;
    end_token_ = curr_;
    end_start_state_ = 0;
    goto end;

state1_0:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == '[') goto state1_1;

    if (ch_ == ',') goto state1_2;

    if (ch_ == ']') goto state1_3;
    goto end;

state1_1:
    end_state_ = true;
    id_ = 91;
    uid_ = 1;
    end_token_ = curr_;
    end_start_state_ = 1;
    goto end;

state1_2:
    end_state_ = true;
    id_ = 44;
    uid_ = 2;
    end_token_ = curr_;
    end_start_state_ = 1;
    goto end;

state1_3:
    end_state_ = true;
    id_ = 93;
    uid_ = 3;
    end_token_ = curr_;
    end_start_state_ = 1;
    goto end;

state2_0:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == '+' || ch_ == '-') goto state2_1;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_2;

    if (ch_ == '.') goto state2_3;

    if (ch_ == ',') goto state2_4;

    if (ch_ == ']') goto state2_5;
    goto end;

state2_1:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_2;

    if (ch_ == '.') goto state2_3;
    goto end;

state2_2:
    end_state_ = true;
    id_ = 65536;
    uid_ = 4;
    end_token_ = curr_;
    end_start_state_ = 2;

    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_2;

    if (ch_ == '.') goto state2_6;

    if (ch_ == 'E' || ch_ == 'e') goto state2_7;
    goto end;

state2_3:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_8;
    goto end;

state2_4:
    end_state_ = true;
    id_ = 44;
    uid_ = 5;
    end_token_ = curr_;
    end_start_state_ = 2;
    goto end;

state2_5:
    end_state_ = true;
    id_ = 93;
    uid_ = 6;
    end_token_ = curr_;
    end_start_state_ = 2;
    goto end;

state2_6:
    end_state_ = true;
    id_ = 65536;
    uid_ = 4;
    end_token_ = curr_;
    end_start_state_ = 2;

    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_6;

    if (ch_ == 'E' || ch_ == 'e') goto state2_7;
    goto end;

state2_7:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == '+' || ch_ == '-') goto state2_9;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_10;
    goto end;

state2_8:
    end_state_ = true;
    id_ = 65536;
    uid_ = 4;
    end_token_ = curr_;
    end_start_state_ = 2;

    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'E' || ch_ == 'e') goto state2_7;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_8;
    goto end;

state2_9:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_10;
    goto end;

state2_10:
    end_state_ = true;
    id_ = 65536;
    uid_ = 4;
    end_token_ = curr_;
    end_start_state_ = 2;

    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if ((ch_ >= '0' && ch_ <= '9')) goto state2_10;

end:
    if (end_state_)
    {
        // return longest match
        start_token_ = end_token_;
        start_state_ = end_start_state_;

        if (id_ == 0)
        {
            goto again;
        }
    }
    else
    {
        id_ = npos;
        uid_ = npos;
    }

    unique_id_ = uid_;
    return id_;
}

////////////////////////////////////////////////////////////////////////////////
// this defines a generic accessors for the information above
struct lexer_matlib_switch
{
    // version number and feature-set of compatible static lexer engine
    enum
    {
        static_version = 65536,
        supports_bol = false,
        supports_eol = false
    };

    // return the number of lexer states
    static std::size_t state_count()
    {
        return lexer_state_count_matlib_switch; 
    }

    // return the name of the lexer state as given by 'idx'
    static char const* state_name(std::size_t idx)
    {
        return lexer_state_names_matlib_switch[idx]; 
    }

    // return the next matched token
    template<typename Iterator>
    static std::size_t next(std::size_t &start_state_, bool& bol_
      , Iterator &start_token_, Iterator const& end_, std::size_t& unique_id_)
    {
        return next_token_matlib_switch(start_state_, bol_, start_token_, end_, unique_id_);
    }
};

}}}}}  // namespace boost::spirit::lex::lexertl::static_

#endif
