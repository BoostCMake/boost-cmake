// Copyright (c) 2008-2009 Ben Hanson
// Copyright (c) 2008-2011 Hartmut Kaiser
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file licence_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// Auto-generated by boost::lexer, do not edit

#if !defined(BOOST_SPIRIT_LEXER_NEXT_TOKEN_TEST_SWITCH_OCT__3_2018_21_58_47)
#define BOOST_SPIRIT_LEXER_NEXT_TOKEN_TEST_SWITCH_OCT__3_2018_21_58_47

#include <boost/detail/iterator.hpp>
#include <boost/spirit/home/support/detail/lexer/char_traits.hpp>

////////////////////////////////////////////////////////////////////////////////
// the generated table of state names and the tokenizer have to be
// defined in the boost::spirit::lex::lexertl::static_ namespace
namespace boost { namespace spirit { namespace lex { namespace lexertl { namespace static_ {

////////////////////////////////////////////////////////////////////////////////
// this table defines the names of the lexer states
wchar_t const* const lexer_state_names_test_switch[1] = 
{
    L"INITIAL"
};

////////////////////////////////////////////////////////////////////////////////
// this variable defines the number of lexer states
std::size_t const lexer_state_count_test_switch = 1;

////////////////////////////////////////////////////////////////////////////////
// this function returns the next matched token
template<typename Iterator>
std::size_t next_token_test_switch (std::size_t& /*start_state_*/, bool& /*bol_*/, 
    Iterator &start_token_, Iterator const& end_, std::size_t& unique_id_)
{
    static std::size_t const npos = static_cast<std::size_t>(~0);

    if (start_token_ == end_)
    {
        unique_id_ = npos;
        return 0;
    }

    Iterator curr_ = start_token_;
    bool end_state_ = false;
    std::size_t id_ = npos;
    std::size_t uid_ = npos;
    Iterator end_token_ = start_token_;

    wchar_t ch_ = 0;

    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'Y') goto state0_1;
    goto end;

state0_1:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'a') goto state0_2;
    goto end;

state0_2:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'y') goto state0_3;
    goto end;

state0_3:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == ' ') goto state0_4;
    goto end;

state0_4:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'w') goto state0_5;
    goto end;

state0_5:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'i') goto state0_6;
    goto end;

state0_6:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'n') goto state0_7;
    goto end;

state0_7:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'n') goto state0_8;
    goto end;

state0_8:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'i') goto state0_9;
    goto end;

state0_9:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'n') goto state0_10;
    goto end;

state0_10:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == 'g') goto state0_11;
    goto end;

state0_11:
    if (curr_ == end_) goto end;
    ch_ = *curr_;
    ++curr_;

    if (ch_ == '!') goto state0_12;
    goto end;

state0_12:
    end_state_ = true;
    id_ = 65536;
    uid_ = 0;
    end_token_ = curr_;

end:
    if (end_state_)
    {
        // return longest match
        start_token_ = end_token_;
    }
    else
    {
        id_ = npos;
        uid_ = npos;
    }

    unique_id_ = uid_;
    return id_;
}

////////////////////////////////////////////////////////////////////////////////
// this defines a generic accessors for the information above
struct lexer_test_switch
{
    // version number and feature-set of compatible static lexer engine
    enum
    {
        static_version = 65536,
        supports_bol = false,
        supports_eol = false
    };

    // return the number of lexer states
    static std::size_t state_count()
    {
        return lexer_state_count_test_switch; 
    }

    // return the name of the lexer state as given by 'idx'
    static wchar_t const* state_name(std::size_t idx)
    {
        return lexer_state_names_test_switch[idx]; 
    }

    // return the next matched token
    template<typename Iterator>
    static std::size_t next(std::size_t &start_state_, bool& bol_
      , Iterator &start_token_, Iterator const& end_, std::size_t& unique_id_)
    {
        return next_token_test_switch(start_state_, bol_, start_token_, end_, unique_id_);
    }
};

}}}}}  // namespace boost::spirit::lex::lexertl::static_

#endif
